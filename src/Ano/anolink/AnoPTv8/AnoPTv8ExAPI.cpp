#include "AnoPTv8ExAPI.hpp"

#include "anoSerial.hpp"
#include "anoUdp.hpp"
#include "anolink.hpp"
/***********************************************************************************************************************************************
************************************************************************************************************************************************
************************************************************************************************************************************************
移植STEP1：
实现AnoPTv8HwSendBytes和AnoPTv8HwTrigger1ms函数，一个是连接底层硬件实现数据发送，一个是1毫秒周期执行，判断是否有数据需要收发
如果只需要向上位机发送数据进行显示，不需要参数读写、命令执行等功能，那么只需要实现这两个函数即可，后续步骤不需要进行
************************************************************************************************************************************************
************************************************************************************************************************************************
***********************************************************************************************************************************************/
/*AnoPTv8HwSendBytes此函数需要根据用户自己的设备，具体实现，比如使用串口连接上位机，这里就对应该串口的发送函数
注意：串口驱动务必使用中断+缓冲区或者DMA+缓冲区的方式，阻塞式发送将大大影响系统性能
注意：串口缓冲区不应过小，推荐256字节或以上
这里需引用对应的串口h文件*/

void AnoPTv8HwSendBytes(const uint16_t linktype, const uint8_t* buf, const uint16_t len) {
    if (LT_UDP_UPPC & linktype) {
        AnoLink::m_self->m_udpUpPc->addTxData(buf, len);
    }
    if (LT_U1 & linktype) {
        AnoLink::m_self->m_serialFC->addTxData(buf, len);
    }
    // if (LT_U2 & linktype) DrvUart2SendBuf(buf, len);
    // if (LT_U3 & linktype) DrvUart3SendBuf(buf, len);
    // if (LT_U4 & linktype) DrvUart4SendBuf(buf, len);
    // if (LT_U5 & linktype) DrvUart5SendBuf(buf, len);
}
/*用户需要在1ms定时中断或者系统滴答或者自己设计的调度器内以1ms的时间间隔调用此函数*/
void AnoPTv8HwTrigger1ms(void) { AnoPTv8RunThread1ms(); }
/***********************************************************************************************************************************************
************************************************************************************************************************************************
************************************************************************************************************************************************
移植STEP2：
实现AnoPTv8HwRecvByte函数，是连接底层硬件实现数据接收，实现本函数后，即可实现上位机读取设备信息
************************************************************************************************************************************************
************************************************************************************************************************************************
***********************************************************************************************************************************************/
/*AnoPTv8HwRecvByte此函数已在AnoPTv8ExAPI.h中声明，用户需要在对应串口的接收事件中调用此函数
注意：此函数传入的是字节数据，如果接收事件接收到的数据大于1字节，多次调用此函数即可*/
void AnoPTv8HwRecvByte(const uint16_t linktype, const uint8_t dat) { AnoPTv8RecvOneByte(linktype, dat); }
/***********************************************************************************************************************************************
************************************************************************************************************************************************
************************************************************************************************************************************************
移植STEP3：
实现参数读写，具体教程请参见https://gitee.com/anotc/AnoAssistant/
************************************************************************************************************************************************
************************************************************************************************************************************************
***********************************************************************************************************************************************/
void AnoPTv8HwParValRecvCallback(const uint16_t linktype, const _un_frame_v8* p) {
    (void)linktype;
    (void)p;
}

void AnoPTv8HwParCmdRecvCallback(const uint16_t linktype, const _un_frame_v8* p) {
    (void)linktype;
    (void)p;
}

/***********************************************************************************************************************************************
************************************************************************************************************************************************
************************************************************************************************************************************************
移植STEP4：
实现命令读写，具体教程请参见https://gitee.com/anotc/AnoAssistant/
************************************************************************************************************************************************
************************************************************************************************************************************************
***********************************************************************************************************************************************/

/***********************************************************************************************************************************************
************************************************************************************************************************************************
************************************************************************************************************************************************
移植STEP_：
实现数据解析，命令帧、参数帧在AnoPTv8Run中已经解析，这里可以用于解析其他数据帧
************************************************************************************************************************************************
************************************************************************************************************************************************
***********************************************************************************************************************************************/
void AnoPTv8FrameAnl(const uint8_t linktype, const _un_frame_v8* p) {
    AnoLink::m_self->RxV8FrameCB(linktype, p);
}
/***********************************************************************************************************************************************
************************************************************************************************************************************************
************************************************************************************************************************************************
移植STEP_：
实现数据转发，可选功能，用户可不实现本函数，函数留空即可。
当一个设备上，有多个基于匿名协议通信的设备时，可实现本函数
以拓空者飞控为例，飞控串口5接数传或通过USB接口和上位机通信，同时串口4默认接匿名光流，就可以利用本函数，实现通过数传，
数据统一发给拓空者，拓空者根据数据帧的目的地址字节，判断数据是否需要转发
************************************************************************************************************************************************
************************************************************************************************************************************************
***********************************************************************************************************************************************/
void AnoPTv8FrameExchange(const uint8_t linktype, const _un_frame_v8* p) {
    // 情景1：广播数据
    if (ANOPTV8DEVID_ALL == p->frame.ddevid) {
        if (ANOPTV8DEVID_SWJ == p->frame.sdevid) {
            // 如果是上位机发出的广播数据，则转发给所有匿名设备
            if (LT_D_SWJ & linktype) {
                AnoPTv8HwSendBytes(LT_D_IMU, p->rawBytes, p->frame.datalen + ANOPTV8_FRAME_HEADLEN + 2);
            }
        }
        else {
            // 如果不是上位机的广播数据，只可能是传感器发出的广播数据，不进行转发或自己进行选择性转发
            if (0) {
                AnoPTv8HwSendBytes(LT_D_SWJ, p->rawBytes, p->frame.datalen + ANOPTV8_FRAME_HEADLEN + 2);
            }
        }
    }
    // 情景2：非广播数据，直接根据目的设备ID进行转发
    else {
        switch (p->frame.ddevid) {
        case ANOPTV8DEVID_LXIMU:
            AnoPTv8HwSendBytes(LT_D_IMU, p->rawBytes, p->frame.datalen + ANOPTV8_FRAME_HEADLEN + 2);
            break;
        case ANOPTV8DEVID_OF:
            AnoPTv8HwSendBytes(LT_U4, p->rawBytes, p->frame.datalen + ANOPTV8_FRAME_HEADLEN + 2);
            break;
        case ANOPTV8DEVID_SWJ:
            AnoPTv8HwSendBytes(LT_D_SWJ, p->rawBytes, p->frame.datalen + ANOPTV8_FRAME_HEADLEN + 2);
            break;
        case ANOPTV8DEVID_UART1:
            AnoPTv8HwSendBytes(LT_U1, p->rawBytes, p->frame.datalen + ANOPTV8_FRAME_HEADLEN + 2);
            break;
        case ANOPTV8DEVID_UART2:
            AnoPTv8HwSendBytes(LT_U2, p->rawBytes, p->frame.datalen + ANOPTV8_FRAME_HEADLEN + 2);
            break;
        case ANOPTV8DEVID_UART3:
            AnoPTv8HwSendBytes(LT_U3, p->rawBytes, p->frame.datalen + ANOPTV8_FRAME_HEADLEN + 2);
            break;
        case ANOPTV8DEVID_UART4:
            AnoPTv8HwSendBytes(LT_U4, p->rawBytes, p->frame.datalen + ANOPTV8_FRAME_HEADLEN + 2);
            break;
        case ANOPTV8DEVID_UART5:
            AnoPTv8HwSendBytes(LT_U5, p->rawBytes, p->frame.datalen + ANOPTV8_FRAME_HEADLEN + 2);
            break;
        }
    }
}
